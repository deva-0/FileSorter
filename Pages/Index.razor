@page "/"
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage;
@using Sorter.Data;
@using Blazored.Toast.Configuration;
@inject FileService FileService
@inject IJSRuntime theJavaScriptEngine
@inject IHostApplicationLifetime AppLifetime
@inject IToastService toastService
@inject ProtectedSessionStorage ProtectedSessionStore

<h1>Sorter</h1>

@switch (status)
{
    case Status.BeforeInit:
        <div class="row mb-3">
            <div class="col">
                <p>Click to start</p>
            </div>
        </div>
        <div class="row mb-3">
            <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-primary" buttonName="Init session" buttonOnClick="InitSession" />
            <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-outline-secondary" buttonName="Configuration" buttonOnClick="ModalConfigurationOpen" />
        </div>
        if (ShowDebugInfo)
        {
            <div class="col col-sm-3">
                <p>
                    INDEX @MyMediaCurrentIndex
                </p>
                @if (null != MyMediaIndexes)
                {
                    foreach (var tuple in MyMediaIndexes)
                    {
                        <p>tupla: @tuple.Item1 | @tuple.Item2</p>
                    }
                }
                <p>
                    status: @status
                </p>
            </div>
        }
        break;
    case Status.Empty:
        <div class="row mb-3">
            <div class="col">
                <p>No more files to sort! You can shutdown app, back to previous file, reset server or reconfigure app.</p>
            </div>
        </div>
        <div class="row mb-3">
            <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-outline-secondary" buttonName="Shut down" buttonOnClick="() => AppLifetime.StopApplication()" />
            <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-secondary" buttonName="Back" buttonOnClick="Back" />
            <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-outline-secondary" buttonName="Reset server" buttonOnClick="Reset" />
            <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-outline-secondary" buttonName="Configuration" buttonOnClick="ModalConfigurationOpen" />
        </div>
        if (ShowDebugInfo)
        {
            <div class="col col-sm-3">
                <p>
                    INDEX @MyMediaCurrentIndex
                </p>
                @if (null != MyMediaIndexes)
                {
                    foreach (var tuple in MyMediaIndexes)
                    {
                        <p>tupla: @tuple.Item1 | @tuple.Item2</p>
                    }
                }
                <p>
                    status: @status
                </p>
            </div>
        }
        break;
    case Status.Initialized:
        //name and password
        <div class="row mb-3">
            <div class="col-sm-8">
                <p>@file?.PhysicalPath?.Replace(file.Name,"").Replace(file.Extension,"")<strong>@file?.Name.@file?.Extension</strong></p>
            </div>
            <label class="col-sm-2" for="password">Password to unlock more function:</label>
            <div class="col-sm-2">
                <input class="form-control" type="password" id="passwordToUnlock" name="passwordToUnlock" @bind="unlockBoxPassword" @bind:event="oninput">
            </div>
        </div>
        //main buttons
        <div class="row mb-3">
            <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-secondary" buttonName="Back" buttonOnClick="Back" />
            <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-secondary" buttonName="Next" buttonOnClick="Next" />
            @if (truePassword!.Equals(unlockBoxPassword))
            {
                <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-outline-secondary" buttonName="Reset server" buttonOnClick="Reset" />
                <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-outline-secondary" buttonName="Shut down" buttonOnClick="() => AppLifetime.StopApplication()" />
            }
            <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-secondary" buttonName="Add new folder modal" buttonOnClick="ModalFolderCreate" />
            <ButtonInDiv divCssClass="col d-grid" buttonCssClass="btn btn-outline-secondary" buttonName="Configuration" buttonOnClick="ModalConfigurationOpen" />
        </div>
        //folders and media
        <div class="container">
            @*folders*@
            <div class="row row-cols-@cols mb-3">
                @for (int i = 0; i < folders!.Length; i++)
                {
                    var k = i;
                    <ButtonInDiv divCssClass="col d-grid mb-1" buttonCssClass="btn btn-primary" buttonName="@folders[k].Name" buttonOnClick="()=>MoveFile(folders[k].Path)" />
                }
            </div>
            @*rename*@
            @if (truePassword.Equals(unlockBoxPassword) || allowRename)
            {
                <div class="row mb-3">
                    <div class="col-sm-6">
                        <input class="form-control" type="text" id="fileName" name="fileName" @bind="file.Name">
                    </div>
                    <ButtonInDiv divCssClass="col-sm-6" buttonCssClass="btn btn-secondary" buttonName="Save file name" buttonOnClick="SaveFileName" />
                </div>
            }
            @*media*@
            <div class="row mb-3">
                <div class="col col-sm-9">
                    @if (VIDEO_EXTENSIONS.Contains(file?.Extension?.ToLower()))
                    {
                        <video style="max-width:800px;max-height:700px;" controls autoplay id="videoTagId">
                            <source src="@file?.Path" type="video/@file?.Extension">
                            Your browser does not support the video tag.
                        </video>
                    }
                    else if (PHOTO_EXTENSIONS.Contains(file?.Extension?.ToLower()))
                    {
                        <img src="@(string.IsNullOrEmpty(file?.ThumbnailPath)?file?.Path:file?.ThumbnailPath)" style="max-width:800px;max-height:700px;" />
                    }
                    else if ("pdf".Equals(file?.Extension?.ToLower()))
                    {
                        <embed src="@file?.Path" style="width:500px;height:707px;" />
                    }
                    else if (TEXT_EXTENSIONS.Contains(file?.Extension?.ToLower()))
                    {
                        <pre>@GetTextFileContent().Result</pre>
                    }
                    else
                    {
                        <p>Filetype @file?.Extension is already not supported</p>
                    }
                </div>
                <div class="col col-sm-3">
                    <div class="row mb-3">
                        <p>Next photo</p>
                        @if(PHOTO_EXTENSIONS.Contains(file?.Extension?.ToLower())){
                            <img src="@(string.IsNullOrEmpty(file?.ThumbnailPath)?file?.Path:file?.ThumbnailPath)" style="max-width:400px" />
                        }
                        else
                        {
                            <p>Next file is not photo</p>
                        }
                    </div>
                    <div class="row mb-3">
                        <p>Previous photo</p>
                        @if(PHOTO_EXTENSIONS.Contains(file?.Extension?.ToLower())){
                            <img src="@(string.IsNullOrEmpty(file?.ThumbnailPath)?file?.Path:file?.ThumbnailPath)" style="max-width:400px" />
                        }
                        else
                        {
                            <p>Next file is not photo</p>
                        }
                    </div>
                    @if (ShowDebugInfo)
                {
                <div class="row mb-3">
                    <p>
                        INDEX @MyMediaCurrentIndex
                    </p>
                    @if (null != MyMediaIndexes)
                    {
                        foreach (var tuple in MyMediaIndexes)
                        {
                            <p>tupla: @tuple.Item1 | @tuple.Item2</p>
                        }
                    }
                    <p>
                        status: @status
                    </p>
                </div>
                }
                </Div>
            </div>
        </div>
        break;
}

@if (ModalFolderIsOpen)
{
    <Dialog Caption="Add new folder"
        Message="Insert name for new folder"
        AdditionalValuesToNotRepeat="@folders?.Select(f=>f.Name).ToArray()"
        OnCloseWithValue="@ModalFolderClose"
        OnClose="@ModalFolderCancel"
        Type="Dialog.Category.FolderAdd" />
}
@if (ModalConfigurationIsOpen)
{
    <ConfigDialog OnClose="@ModalConfigurationClose" />
}

<BlazoredToasts Position="ToastPosition.BottomRight" IconType="IconType.Material" ShowProgressBar="true" RemoveToastsOnNavigation="true" PauseProgressOnHover="true" MaxToastCount="3" Timeout="10" />

@code {
    private const string StorageMyMediaList = "_MyMediaIndexes";
    private const string StorageMyMediaCurrentIndex = "_MyMediaCurrentIndex";
    private const string StorageStatus = "_Status";
    private string StoragePrefix; //TODO check if we need use this
    private const bool ShowDebugInfo = true;

    private static string[] VIDEO_EXTENSIONS = { "avi", "mp4", "m4v", "ogv", "webm", "mov", "wmv", "flv" }; //not sure if all of them works
    private static string[] PHOTO_EXTENSIONS = { "gif", "jpeg", "jpg", "png", "webp", "apng", "avif" }; //supported by <img> tag
    private static string[] TEXT_EXTENSIONS = { "txt" };
    private const int LOAD_VIDEO_TIME_DELAY = 100;
    private const int MOVE_FILE_TIME_DELAY = 500;
    private const int BRAJANEK = 4; // its MAX_COLUMN_NUMBER but i really need to name this like that. Please, respect this and do not change.

    private List<Tuple<int, string>>? MyMediaIndexes;
    private int MyMediaCurrentIndex;
    private File? file;
    private Folder[]? folders;
    private double? cols;
    private string unlockBoxPassword = string.Empty;
    private string? truePassword;
    private bool allowRename;
    private bool ModalFolderIsOpen = false;
    private bool ModalConfigurationIsOpen = false;
    private Status status = Status.OnConstructor;


    public enum Status
    {
        OnConstructor,
        BeforeInit,
        Initialized,
        Empty,
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _PSSReadStatus();
            switch (status)
            {
                case Status.OnConstructor:
                    status = Status.BeforeInit;
                    break;
                case Status.BeforeInit:
                    break;
                case Status.Initialized:
                    await _PSSReadMyMediaIndexes();
                    await _PSSReadMyMediaCurrentIndex();
                    LoadSession(MyMediaIndexes![MyMediaCurrentIndex].Item1, MyMediaIndexes[MyMediaCurrentIndex].Item2);
                    break;
                case Status.Empty:
                    await _PSSReadMyMediaIndexes();
                    await _PSSReadMyMediaCurrentIndex();
                    break;
            }
        }
        if (firstRender) StateHasChanged();
    }
    private async void LoadSession(int index, string fileName = "")
    {
        try{
            file = string.IsNullOrEmpty(fileName) ? FileService.GetFileAtIndex(index) : FileService.GetFileAtIndex(index, fileName);
            folders = await FileService.GetFoldersAsync();
            cols = Math.Min(Math.Ceiling(Math.Sqrt(folders.Length)), BRAJANEK);
            truePassword = await FileService.GetTruePassword();
            allowRename = await FileService.GetAllowRename();
        }
        catch
        {
            status = Status.BeforeInit;
            await _ResetProtectedSessionStore();
        }
    }
    private async void InitSession()
    {
        int? index = FileService.GetNextIndex();
        if (index.HasValue)
        {
            LoadSession(index.Value);
            MyMediaIndexes = new List<Tuple<int, string>>() { new Tuple<int, string>(file!.FIndex!.Value, file.Name) };
            MyMediaCurrentIndex = 0;
            status = Status.Initialized;
            await _PSSWriteMyMediaIndexes();
            await _PSSWriteMyMediaCurrentIndex();
            await _PSSWriteStatus();
            StateHasChanged();
        }
        else
        {
            MyMediaIndexes = null;
            MyMediaCurrentIndex = -1;
            status = Status.Empty;
            await _PSSWriteStatus();
            StateHasChanged();
            toastService.ShowError("There is no files to show - are paths are valid? Check it on the configuration page");
        }
    }
    private async void Reset()
    {
        await _ResetProtectedSessionStore();
        FileService.ResetFiles();
        InitSession();
        ReloadPlayerIfVideo();
        StateHasChanged();
    }
    private async void GetNextFileFromOurTab()
    {
        MyMediaCurrentIndex++;
        try
        {
            file = FileService.GetFileAtIndex(MyMediaIndexes![MyMediaCurrentIndex].Item1, MyMediaIndexes[MyMediaCurrentIndex].Item2);
            await _PSSWriteMyMediaCurrentIndex();
        }
        catch (Exception)
        {
            await _ResetProtectedSessionStore();
            StateHasChanged();
        }
    }
    private async void GetNextFileFromFileService()
    {
        int? index = FileService.GetNextIndex();
        if (index.HasValue)
        {
            file = FileService.GetFileAtIndex(index.Value);
            if (MyMediaIndexes!.Where(t => t.Item1 == index.Value).Any())
            {
                if (MyMediaIndexes!.Where(t => t.Item1 == index.Value && t.Item2.Equals(file.Name)).Any())
                {
                    MyMediaIndexes = new List<Tuple<int, string>>() { new Tuple<int, string>(file!.FIndex!.Value, file.Name) };
                    MyMediaCurrentIndex = 0;
                    await _PSSWriteMyMediaIndexes();
                }
                else
                {
                    MyMediaIndexes = null;
                    MyMediaCurrentIndex = -1;
                    status = Status.BeforeInit;
                    await _ResetProtectedSessionStore();
                    StateHasChanged();
                }
            }
            else
            {
                MyMediaIndexes!.Add(new Tuple<int, string>(file!.FIndex!.Value, file.Name));
                await _PSSWriteMyMediaIndexes();
                MyMediaCurrentIndex++;
            }
            await _PSSWriteMyMediaCurrentIndex();
            StateHasChanged();
        }
        else
        {
            MyMediaCurrentIndex++;
            status = Status.Empty;
            await Task.WhenAll(_PSSWriteStatus(), _PSSWriteMyMediaCurrentIndex());
        }
    }
    private async void Next()
    {
        if (MyMediaCurrentIndex < MyMediaIndexes!.Count - 1) GetNextFileFromOurTab();
        else GetNextFileFromFileService();

        ReloadPlayerIfVideo();
        StateHasChanged();
    }
    private async void Back()
    {
        if (MyMediaCurrentIndex <= 0)
        {
            toastService.ShowWarning("No more files");
            return;
        }
        MyMediaCurrentIndex--;
        try
        {
            if (!status.Equals(Status.Initialized))
            {
                LoadSession(MyMediaIndexes![MyMediaCurrentIndex].Item1, MyMediaIndexes[MyMediaCurrentIndex].Item2);
                status = Status.Initialized;
                await _PSSWriteStatus();
            }
            else
            {
                file = FileService.GetFileAtIndex(MyMediaIndexes![MyMediaCurrentIndex].Item1, MyMediaIndexes[MyMediaCurrentIndex].Item2);
            }
            ReloadPlayerIfVideo();
            StateHasChanged();
            await _PSSWriteMyMediaCurrentIndex();
        }
        catch (Exception)
        {
            MyMediaIndexes = null;
            MyMediaCurrentIndex = -1;
            status = Status.BeforeInit;
            await _ResetProtectedSessionStore();
            StateHasChanged();
        }
    }
    private async void MoveFile(string destiny)
    {
        if (file == null) return;
        var oldFile = file;
        Next();
        await Task.Delay(MOVE_FILE_TIME_DELAY);
        FileService.MoveFile(oldFile, destiny);
    }
    private async Task<string> GetTextFileContent()
    {
        return await FileService.GetTextFileContent(file);
    }
    private async void SaveFileName()
    {
        FileService.ChangeFileName(file.FIndex.Value, file.Name);
        file = FileService.GetFileAtIndex(file!.FIndex!.Value);
        MyMediaIndexes![MyMediaCurrentIndex] = new Tuple<int, string>(file!.FIndex!.Value, file.Name);
        await _PSSWriteMyMediaIndexes();
        StateHasChanged();

    }
    private void ModalFolderCreate()
    {
        ModalFolderIsOpen = true;
        StateHasChanged();
    }
    private async Task ModalFolderClose(string folderName)
    {
        if (!String.IsNullOrWhiteSpace(folderName))
        {
            if (FileService.CreateFolder(folderName))
            {
                folders = await FileService.GetFoldersAsync();
            }
        }
        ModalFolderIsOpen = false;
    }
    private async Task ModalFolderCancel(bool isOk)
    {
        ModalFolderIsOpen = false;
    }
    private void ModalConfigurationOpen()
    {
        ModalConfigurationIsOpen = true;
        StateHasChanged();
    }
    private async Task ModalConfigurationClose(bool isOk)
    {
        ModalConfigurationIsOpen = false;
        if (isOk)
        {
            //StateHasChanged();
            status = Status.BeforeInit;
            await _PSSWriteStatus();
        }
    }
    private async void ReloadPlayerIfVideo()
    {
        if (VIDEO_EXTENSIONS.Contains(file?.Extension?.ToLower()))
        {
            await Task.Delay(LOAD_VIDEO_TIME_DELAY);
            await theJavaScriptEngine.InvokeVoidAsync("loadVideo");
        }
    }


    private async Task _PSSReadMyMediaIndexes()
    {
        MyMediaIndexes = (await ProtectedSessionStore.GetAsync<List<Tuple<int, string>>>(StorageMyMediaList)).Value;
    }
    private async Task _PSSReadMyMediaCurrentIndex()
    {
        MyMediaCurrentIndex = (await ProtectedSessionStore.GetAsync<int>(StorageMyMediaCurrentIndex)).Value;
    }
    private async Task _PSSReadStatus()
    {
        status = (await ProtectedSessionStore.GetAsync<Status>(StorageStatus)).Value;
    }
    private async Task _PSSWriteMyMediaIndexes()
    {
        await ProtectedSessionStore.SetAsync(StorageMyMediaList, MyMediaIndexes);
    }
    private async Task _PSSWriteMyMediaCurrentIndex()
    {
        await ProtectedSessionStore.SetAsync(StorageMyMediaCurrentIndex, MyMediaCurrentIndex);
    }
    private async Task _PSSWriteStatus()
    {
        await ProtectedSessionStore.SetAsync(StorageStatus, status);
    }
    private async Task _PSSDeleteMyMediaIndexes()
    {
        await ProtectedSessionStore.DeleteAsync(StorageMyMediaList);
    }
    private async Task _PSSDeleteMyMediaCurrentIndex()
    {
        await ProtectedSessionStore.DeleteAsync(StorageMyMediaCurrentIndex);
    }
    private async Task _PSSDeleteStatus()
    {
        await ProtectedSessionStore.DeleteAsync(StorageStatus);
    }
    private async Task _ResetProtectedSessionStore()
    {
        await _PSSDeleteMyMediaCurrentIndex();
        await _PSSDeleteMyMediaIndexes();
        await _PSSDeleteStatus();
    }
}
